import { Event } from '@linode/api-v4/lib/account';
import { getLinode } from '@linode/api-v4/lib/linodes';
import { getVolume, Volume } from '@linode/api-v4/lib/volumes';
import { clone } from 'ramda';
import * as React from 'react';
import { Subject } from 'rxjs/Subject';
import { Subscription } from 'rxjs/Subscription';

import { events$ } from 'src/events';

export const updateVolumes$ = new Subject<boolean>();

interface State {
  volumes?: Volume[];
}

export default () => (WrappedComponent: React.ComponentType<any>) => {
  return class extends React.Component<any, State> {
    state: State = {
      volumes: undefined,
    };
    eventsSub: Subscription;

    mounted: boolean = false;

    componentDidMount() {
      this.mounted = true;
      this.eventsSub = events$
        .filter(
          (event) =>
            !event._initial &&
            [
              'volume_create',
              'volume_attach',
              'volume_delete',
              'volume_detach',
              'volume_resize',
              'volume_clone',
            ].includes(event.action)
        )
        .merge(updateVolumes$)
        .subscribe((event: Event) => {
          /**
           * This solves for one scenario - we're editing the Volume label
           * and we want to force a refresh after submitting the form
           *
           * @todo remove/refactor this functionality once a unified volumes platform is developed
           */
          if (!event.entity) {
            return this.props.request();
          }

          const entityId = event.entity.id;

          /*
           * If we're deleting a Volume, don't do anything fancy.
           * Just re-request the page of Volumes
           */
          if (['volume_detach', 'volume_delete'].includes(event.action)) {
            /* onDelete handler generated by Pagey */
            return this.props.onDelete();
          }

          /** if our volume finished provisioning, refresh the list of Volumes */
          if (
            ['volume_create', 'volume_attach', 'volume_clone'].includes(
              event.action
            )
          ) {
            return this.props.request();
          }

          /**
           * if we've gotten to this point, this means we're taking some action on
           * an existing volume, such as attaching or detaching, so we're going to update
           * the list of Volumes not calling getVolumes(), but instead requesting the Volume
           * that's in the middle of updating and insert it into our current list of Volumes
           */
          getVolume(entityId).then((volume: Volume) => {
            if (!this.mounted || !this.props.data) {
              return;
            }

            /*
             * find the index of the volume we have to update/replace in our current dataset
             *
             * Always check this.state.volumes first because if this component's state has
             * been set, that means we've updated another Volume from the original dataset
             * at some point previously
             */
            const targetIndex = (
              this.state.volumes || this.props.data
            ).findIndex((eachVolume: Volume) => {
              return eachVolume.id === entityId;
            });

            /** if the volume never appeared in our dataset, no updating needed */
            if (targetIndex === -1) {
              return;
            }

            /*
             * make a clone of state or prop data, depending on if state data exists
             */
            const clonedVolumes = clone(this.state.volumes || this.props.data);

            /*
             * If the volume has a Linode ID, it means that it's just been
             * attached. So, now we have to make a request to the Linode
             * that it was just attached to, so that we can display the
             * Linode info in the table row
             */
            if (!!volume.linode_id) {
              return getLinode(volume.linode_id).then((response) => {
                const linode = response;

                /*
                 * Now add our new volume, include the newly attached
                 * Linode data to the list
                 */
                clonedVolumes[targetIndex] = {
                  ...volume,
                  ...maybeAddEvent(event, volume),
                  linodeLabel: linode.label,
                  linodeStatus: linode.status,
                };

                // finally update the list of volumes in state
                this.setState({
                  volumes: clonedVolumes,
                });
              });
            }

            // now add our new volume with the event data to the list of volumes
            clonedVolumes[targetIndex] = {
              ...volume,
              ...maybeAddEvent(event, volume),
            };

            // finally update the list of volumes
            this.setState({
              volumes: clonedVolumes,
            });
            return;
          });
        });
    }

    componentWillUnmount() {
      this.mounted = false;
    }

    componentDidUpdate(prevProps: any, prevState: any) {
      /*
       * If our data returned from Pagey is different from the original data,
       * it means we either changed pages or page size. In this case, override
       * whatever state we might have set in the events stream logic because
       * the state might have been set in the event stream logic
       */
      if (prevProps.data !== this.props.data) {
        this.setState({ volumes: this.props.data });
      }
    }

    render() {
      return (
        /*
         * Either return this.props.data that comes from Pagey or
         * return the altered data from the event stream
         */
        <WrappedComponent
          {...this.props}
          data={this.state.volumes || this.props.data}
        />
      );
    }
  };
};

const maybeAddEvent = (e: boolean | Event, volume: Volume) => {
  if (typeof e === 'boolean') {
    return {};
  }
  if (!e.entity || e.entity.id !== volume.id) {
    return {};
  }
  return { recentEvent: e };
};
